
1. Cover all values of a random variable between 0 and 100.

covergroup a_range;
  coverpoint a {
    bins all_vals[] = {[0:100]};
  }
endgroup;

*------------------------------------------------------------------------------------------------------------------------------------------*

2. Cover even, odd, and multiple-of-10 numbers for a 0–100 range.

covergroup a_range;
  coverpoint a{
    bins a_even[]    = {[0:100]} with (item %2 ==0);
    bins a_odd[]     = {[0:100]} with (item%2 !=0);
    bins a_mul10[]   = {[0:100]} with (item%10 == 0);
  }
endgroup

*------------------------------------------------------------------------------------------------------------------------------------------*

3. Cover each card in a 52-card deck.

typdef enum {SPADE, HEART, DIAMOND, CLUB} suit_t;

class card;
  suit_t suit;
  rand int unsigned rank;
  constraint c1 { rank inside {[1:13]}; }
endclass

covergroup card_range;
  coverpoint rank { bins ranks[] = {[1:13]} ; }
  coverpoint suit;

  cross rank, suit;
endgroup

*------------------------------------------------------------------------------------------------------------------------------------------*

4. Cover student scores in bins: 0–50, 51–75, 76–100.

class const;
  rand int scores;
  covergroup rang;
    coverpoint scores {
      bins sc1 = {[0:50]};
      bins sc2 = {[51:75]};
      bins sc3 = {[76:100]};
    }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

5. Cover all transaction types and amount ranges.

typdef enum {READ, WRITE, UPDATE, DELETE} txn_ty;
class transaction;
  rand txn_ty t1;
  rand int amount;

covergroup g1;
  coverpoint t1;
  coverpoint amount {
    bins1 = {[0:50]};
    bins2 = {[51:100]};
    bins3 = {[101:150]};
  }
cross t1, amount;
endgroup

*------------------------------------------------------------------------------------------------------------------------------------------*

6. Cover dice values from 1 to 6 uniformly.

class const;
  rand int dice;
  constraint c1 { dice inside [1,2,3,4,5,6];}

covergroup c12;
  coverpoint dice[] = {[1:6]};
endgroup

endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

7. Cover traffic light durations: green (30–60), yellow (5–10), red (50–90).

class const;
  rand int green, yellow, red;
  covergroup traffic;
    coverpoint green {
      bins g[] = {[30:60]};
    }
    coverpoint yellow {
      bins y[] = {[5:10]};
    }
    coverpoint red {
      bins r[] = {[50:90]};
    }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

8. Cover temperature sensor readings in 5 bins.

  class const;
    rand int temp;
    constraint c1 { temp inside {[0:100]}; }
    covergroup c12 @(posedge clk);
      coverpoint temp { 
        bins very_low = {[0:20]};
        bins low = {[21:40]};
        bins med = {[41:60]};
        bins high = {[61:80]};
        bins very_high = {[81:100]};
        }
    endgroup
  endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

9. Cover different lengths of burst transactions: 1, 2, 4, 8, 16.

class const;
  rand int burst_len;

  constraint c1 {
    burst_len inside {1,2,4,8,16};
  }
  covergroup burst;
    coverpoint burst_len {
      bins len_1 = {1};
      bins len_2 = {2};
      bins len_4 = {4};
      bins len_8 = {8};
      bins len_16 = {16};
    }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

10. Cover all combinations of signal A (0/1) and signal B (0/1).

class const;
  logic sig_a, sig_b;
  covergroup signal;
    coverpoint sig_a {
      bins a1[] = {0,1};
      }
    coverpoint sig_b {
      bins b1[] = {0,1};
      }
    cross sig_a, sig_b;
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

11. Cover fsm_state transitions.

class const;
  typedef enum {S1,S2,S3,S4}state_ty;
  rand state_ty state, next_state;

  covergroup s;
    coverpoint state {
      bins state_1[] = {S1,S2,S3,S4};
    }
    coverpoint next_state {
      bins next_state_1[] = {S1,S2,S3,S4};
    }
    cross state, next_state;
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

12. Cover id field values from 0 to 15 in a packet.

class const;
  rand int id;
  covergroup field_value @(posedge clk);
    coverpoint id {
      bins id_bins[] = {[0:15]};
      }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

13. Cover binary vector values with even number of 1s.
class const;
  rand logic [7:0] data;
  covergroup bin_vector @(posedge clk);
    coverpoint arr {
      bins arr_bin[] = {[0:$}} with ($countones(item)%2 == 0);
    }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

14. Cover all valid IP address ranges (first byte: 10, 172, 192).
class const;
  rand int byte1, byte2, byte3, byte4;
  covergroup ip_addr;
    coverpoint byte1 { 
      bins byte_1[] = {10,172,192}; }
      coverpoint byte2 { bins byte_2[] = {[0:255]}; }
      coverpoint byte3 { bins byte_3[] = {[0:255]}; }
      coverpoint byte4 { bins byte_4[] = {[0:255]}; }
        }
    endgroup

  function new();
    ip_addr = new();
  endfunction
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

15. Cover valid and invalid packet types.
typdef enum {VALID, INVALID} state_ty;
class const;
  rand state_ty ty;
  covergroup c1;
    coverpoint ty { bins valid_bin = {VALID};
                    bins invalid_bin = {INVALID}; }

  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

16. Cover timing delays: 0–1, 2–4, 5–10 cycles.
class const;
  rand int delay;
  covergroup c1 ;
    coverpoint delay { bins delay_low[] = {[0:1]};
                        bins delay_med[] = {[2:4]};
                        bins delay_high[] = {[5:10]};
                      }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

17. Cover all priority levels in arbiter (e.g., 0–3).
typedef enum logic [1:0] {LEVEL0, LEVEL1, LEVEL2, LEVEL3} type;
class const;
  rand type ty;
  covergroup c1;
    coverpoint ty { bins levels[] = {LEVEL0, LEVEL1, LEVEL2, LEVEL3}; }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

18. Cover addr value bins in low, mid, high address spaces.
class const;
  rand bit [15:0] addr;
  covergroup c1; 
    coverpoint addr { bins low_addr = {[16'h0000 : 16'h3fff]};
                      bins mid_addr = {[16'h4000 :16'hbfff]};
                      bins high_addr = {[16'hc000: 16'hffff]};
                    }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

19. Cover temperature crossing thresholds: <0, 0–25, 25–50, >50.
class const;
  rand int temp;
  covergroup c1;
    coverpoint temp { bins less_zero = {[-$:-1]};
                      bins mid_twenty = {[0:24]};
                      bins mid_fifty = {[25:49]};
                      bins above_fifty = {[50:$]};
                    }
  endgroup
endclass

*------------------------------------------------------------------------------------------------------------------------------------------*

20. Cover all combinations of protocol flags (QoS, prot, lock, cache).

class const;
  rand bit [1:0] qos;   // Example: 2-bit QoS level
  rand bit prot;        // 1-bit protocol flag
  rand bit lock;        // 1-bit lock flag
  rand bit cache;       // 1-bit cacheable flag

  covergroup c1;
    cp_qos   : coverpoint qos  { bins qos_vals[]   = {[0:3]}; } // QoS levels
    cp_prot  : coverpoint prot { bins prot_vals[]  = {0,1}; }
    cp_lock  : coverpoint lock { bins lock_vals[]  = {0,1}; }
    cp_cache : coverpoint cache{ bins cache_vals[] = {0,1}; }

    // Cross coverage for all combinations
    cross cp_qos, cp_prot, cp_lock, cp_cache;
  endgroup

*------------------------------------------------------------------------------------------------------------------------------------------*

