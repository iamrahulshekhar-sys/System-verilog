NVIDIA Interview questions

 
Q) Floorplan-driven synthesis
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Q) What is boundary scan?
Boundary Scan, standardized as IEEE 1149.1 (JTAG), is a DFT technique where special scan cells are placed at each I/O pin of the IC. These cells form a serial chain that allows controlling and observing pin values through the TAP interface. It enables testing of board-level interconnects without physical probes, improving testability of complex packages like BGAs, and is also widely used for in-system programming and debug.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Q) Scan stitching at block level?
Scan stitching at the block level means inserting scan chains inside each block of a design independently, then exposing scan-in/scan-out ports for integration. At the SoC level, these block-level scan chains are stitched together to form chip-level scan chains. This hierarchical approach simplifies integration, improves reuse of IPs with pre-inserted DFT, and helps balance test complexity across large designs

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Q) Difference: SRAM vs DRAM
SRAM uses a 6-transistor latch cell, doesnâ€™t need refresh, and is faster but less dense and more expensive, so itâ€™s used for caches and register files. DRAM uses a 1T-1C cell, needs periodic refresh since data is stored as charge on a capacitor, but itâ€™s denser and cheaper, making it suitable for main memory.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Q) Application of shift registers
Shift registers are widely used for serial-to-parallel and parallel-to-serial conversion, temporary data storage, delay elements, counters, and sequence generation (like LFSRs for CRC and random numbers). They are also essential in communication systems (UART/SPI), arithmetic operations, and digital signal processing pipelines.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Q) Logic BIST vs MBIST

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
Q) Fault coverage in ATPG

***************************************************************************************************************************************************************************************************

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ¯: ğ—™ğ—¹ğ—¼ğ—¼ğ—¿ğ—½ğ—¹ğ—®ğ—» ğ˜ğ—¼ ğ—¥ğ—¼ğ˜‚ğ˜ğ—²

Q) Key floorplan quality checks
Good floorplan quality is crucial for a successful and timely chip design. Key checks ensure that the physical layout is sound and will not cause problems during later stages like place and route.

1. Timing
The floorplan must support the design's timing goals.
* Timing Closure: Check for early timing analysis results using estimated wire delays. The floorplan should not introduce any major timing violations that can't be fixed later.
* Clock Skew: Ensure that the clock pins of sequential elements (flip-flops, registers) are well-placed to minimize clock skew, which is the difference in clock signal arrival times.
* Critical Paths: Verify that the logic cells on the most critical timing paths are placed close to each other to minimize their interconnect delay.

2. Area and Density
The floorplan needs to be efficient in its use of silicon area.
* Core Utilization: Check the percentage of the core area that is occupied by standard cells. A very high utilization might lead to routing congestion. A very low one wastes silicon.
* Logic Density: Ensure that the logic is distributed evenly throughout the core. Hotspots (areas of high logic density) can cause congestion and local heating issues.
* Aspect Ratio: The ratio of the chip's width to its height should be appropriate. An extreme aspect ratio can make routing difficult and lead to longer wires.

3. Power
Power integrity is vital for chip functionality and reliability.
* Power Grid Integrity: Check that the power and ground rails are wide enough and well-distributed to handle the required current without causing voltage drops (IR drop).
* Power Mesh Continuity: Ensure there are no breaks in the power grid that could starve a portion of the chip of power.

4. Routing
The floorplan must be routable.
* Routing Congestion: The most important check. Use a routing estimation tool to identify areas that are likely to be too crowded for wires to be routed. High congestion is a primary cause of design failures and must be addressed by adjusting cell placement or moving I/O ports.
* I/O and Block Placement: Verify that I/O pads and large IP blocks (like RAM or PLLs) are placed logically to support efficient signal flow with minimal wire length.

5. Electrostatic Discharge (ESD)
The design must be protected from electrostatic discharge.
* ESD Structures: Ensure that the ESD protection circuitry is correctly placed around the I/O pads to protect the internal core from static discharge events.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Macro placement with channel spacing
Macro placement with channel spacing is a key strategy in the physical design of a chip where large, fixed-size blocks (macros or IP blocks) are placed with a specific, empty area, known as a channel, left between them. The primary purpose of these channels is to provide a dedicated, clear area for routing.

Purpose of Channel Spacing

The main goal of channel spacing is to prevent routing congestion.
* The core logic (standard cells) associated with the macros is often placed in the channels.
* Signals that need to connect to the macros or to other parts of the chip are routed through these channels.
* Without adequate spacing, these wires would have to be routed over the top of the macros, which is often difficult or impossible, or they would be packed too tightly, leading to routing failures.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Difference: keep-out vs blockage
In the physical design of an integrated circuit, keep-out and blockage are both types of physical constraints used to control the placement and routing of components. While they are often used interchangeably, they have distinct purposes and behaviors.

Blockage

A blockage is a general term for an area on the chip that is made unavailable for placement or routing. Blockages are typically used to reserve space for future manual placement, to prevent tools from placing logic in a bad location, or to protect critical areas.
There are several types of blockages:
* Placement Blockage: This prevents standard cells (logic gates, flip-flops) from being placed within a specified area.
* Routing Blockage: This prevents the automatic router from drawing interconnect wires within a specified area or on specific metal layers. This is often used to reserve space for a custom clock tree or to avoid noise-sensitive analog circuitry.
* Partial/Soft Blockage: This discourages, but does not strictly prohibit, placement or routing. Tools will try to avoid these areas but can use them if absolutely necessary.
* Hard Blockage: This is a strict prohibition. No cells or wires can be placed in this area.

Keep-Out

A keep-out is a more specific type of placement blockage. Its primary purpose is to prevent specific types of cells from being placed near other cells or within a certain radius.
For example:
* I/O Cell Keep-Out: You might define a keep-out region around sensitive analog I/O pads to prevent noisy digital standard cells from being placed too close, which could cause signal integrity issues.
* Well Tap/Decap Keep-Out: Keep-out regions can be used to prevent tools from placing power-saving "decoupling capacitors" or "well taps" too close to analog macros, which need to be protected from noise.
A keep-out is a relative constraint, often tied to a specific type of cell, whereas a blockage is an absolute constraint on a geometric area.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) How utilization affects IR drop
What are Utilization and IR Drop?

* Utilization: This is the percentage of the core area of a chip that is actually occupied by standard cells (logic gates, flip-flops). A high utilization (e.g., 85%) means the cells are packed very densely.
* IR Drop: This is the voltage drop that occurs across the power and ground rails of a chip due to resistance in the metal interconnects. The "I" stands for current, and the "R" stands for resistance. As current flows through the resistive power grid, a voltage drop (V = I * R) occurs, so the voltage supplied to the cells is lower than the intended voltage.

The Connection: How High Utilization Affects IR Drop

High utilization negatively impacts IR drop primarily because it leads to increased current density and resistance.

1. Increased Current Density
When standard cells are packed tightly together (high utilization), the local current demand in that area becomes very high.
* More cells in a given area means more switching activity, which draws more current from the power grid.
* This concentrated current draw creates a "hotspot" of high current density on the power rails.

2. Increased Resistance (Reduced Routing Resources)
High utilization also has a negative impact on the power grid's effective resistance.
* A dense layout leaves very little space for the power and ground rails.
* The physical design tools have to squeeze the power rails into these narrow gaps, making them thinner and less robust.
* According to the formula for resistance (R=AÏâ‹…L ), a smaller cross-sectional area (A) of the power rail leads to a higher resistance (R).
* The high number of signal wires in a high-utilization area also competes for the same routing tracks as the power grid, further limiting the options for robust power routing.

The Negative Feedback Loop

The relationship between utilization and IR drop can become a negative feedback loop:
1. Start with high utilization: The floorplan is packed tightly to save area.
2. Increased Routing Congestion: The dense layout makes it hard for both signal and power wires to be routed efficiently.
3. Thinner Power Grid: The power grid is squeezed into the remaining space, increasing its resistance.
4. Higher Current Density: The packed cells draw a lot of current from a small area.
5. Significant IR Drop: The combination of high current draw and high resistance causes a large voltage drop, which can lead to timing failures and functional errors.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Sources of routing congestion

Here are the key sources of routing congestion:

1. High Core Utilization
This is the most common and direct cause. When the percentage of the core area filled with standard cells is too high (e.g., above 85%), there is very little empty space left for the routing tool to draw wires. The standard cells themselves have a certain footprint, and the space between them is where the wires are routed. A high utilization rate leaves very little space, making it impossible to connect all the nets.

2. Poor Macro Placement
Incorrect placement of large, fixed-size blocks (macros or IP blocks) can create congestion hotspots.
* Lack of Channel Spacing: If macros are placed too close to each other without sufficient routing channels, the router will struggle to connect the I/O pins of the macros.
* I/O Pin Alignment: If the I/O pins of macros are not aligned or if they are on opposite sides of the chip, the router may have to run long wires through dense areas, creating congestion.

3. I/O Pin Hotspots
I/O pads and pins on the periphery of the chip can be a source of congestion.
* Pin Density: If a large number of signals must be routed to a single, small area on the periphery (e.g., for a specific bus or interface), it can cause a local congestion bottleneck.
* Pad-to-Core Connections: The connection of signals from the I/O pads to the internal logic can create a "traffic jam" if not planned properly.

4. Poor Partitioning
In large designs, the chip is often divided into smaller, manageable partitions.
* Unbalanced Partitions: If a partition is too small for its logic, it will lead to high utilization and congestion within that partition.
* Inter-partition Connectivity: If a large number of signals need to cross between partitions, the small routing channels between them can become highly congested.

5. Complex Clock and Reset Networks
The clock and reset nets are typically routed using dedicated layers to ensure minimal skew.
* Clock Mesh/Grid: A complex clock mesh or grid is used for low skew, but it occupies a significant amount of routing resource on multiple metal layers, potentially creating congestion for signal routing.

6. Power Grid
The power and ground rails are typically very wide to handle high current, and they can occupy a significant portion of the routing layers. If not designed carefully, they can obstruct signal routing and create congestion.

Solutions to Routing Congestion

* Reduce Core Utilization: This is the most effective solution. Reducing the target utilization rate (e.g., from 85% to 75%) leaves more space for routing.
* Optimize Floorplan: Adjusting the placement of macros and adding adequate routing channels is critical.
* Physical-Aware Synthesis: Using tools that consider physical layout information early in the synthesis stage can help create a netlist that is easier to place and route.
* Design Partitions with Routing in Mind: Balance logic density and connectivity when partitioning the design.
* Pin Swapping: Using tools to swap I/O pins of a block can reduce wire length and avoid congestion.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Pin access issues in standard cells
Pin access is a critical consideration in the physical design of an integrated circuit. A standard cell is a basic building block (e.g., an AND gate, a flip-flop) with predefined physical dimensions, pin locations, and timing characteristics. A pin access issue occurs when the automatic placement and routing tools are unable to connect to a standard cell's input or output pins.

Why Pin Access is a Problem

The pins of a standard cell are small metal shapes on a specific metal layer. The routing tool needs to be able to draw an interconnect wire to these pins to connect them to other cells. If a pin is blocked or inaccessible, the tool cannot complete the connection, leading to an unrouted net and a design failure.

Key Causes of Pin Access Issues
1. Overly Aggressive Cell Placement (High Density)
* Too High Utilization: When the design's core utilization is too high, standard cells are packed very tightly together. This leaves very little space between the cells for routing channels.
* Pin "Shadowing": In a dense layout, one cell can be placed so close to another that its body or a neighboring wire physically blocks a pin of an adjacent cell, making it impossible for a router to access the pin.

2. Poorly Designed Standard Cell Library
* Pin Location: A poorly designed standard cell library may have pins that are difficult to access. For example, if all the pins are on the inner part of a cell with no clear routing channel, it will cause routing problems.
* Limited Routing Layers: If a standard cell library restricts pin access to only one or two metal layers, it creates a routing bottleneck on those specific layers, making it harder to connect all the nets.

3. Inefficient Placement of Cells
* Cell Orientation: Standard cells can be placed in different orientations (e.g., flipped, rotated). If a cell's orientation is such that its pins are facing away from the logical connectivity, the router will have to take longer detours, which can increase the chance of blockages.
* Clustering: Placing a large number of cells that have high connectivity to each other in a small, isolated area can create a local congestion and pin access issue.

4. Hard Blockages and Keep-Outs
* Overly Restrictive Constraints: If the physical designer places too many or overly large blockages or keep-out areas, it can limit the available space for the placement and routing tools, forcing them to use sub-optimal locations and creating pin access issues.
* Macro Placement: When standard cells are placed in the channels around large macros, the router has to navigate around the macro's boundaries. If the macro is placed too close to the standard cells, it can block access to their pins.

Solutions

* Lower Utilization: The most direct solution is to reduce the target core utilization to provide more routing space.
* Optimize Floorplan: Adjusting the placement of macros and adding dedicated routing channels can help.
* Pin Access-Aware Placement: Modern placement tools are "pin access-aware" and will try to orient and place cells to minimize pin access problems.
* Library Characterization: Using a high-quality standard cell library that has been characterized for good routability and pin access.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Difference: track-based vs grid routing

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Common routing violations
Violation	Cause	Fix
DRC Violations (Min width, Min spacing, Notch, Enclosure) -->	Routing does not follow foundry rules (too narrow wires, spacing too small, via not enclosed)	Adjust routing rules, widen wires, increase spacing, ensure proper via enclosure
Shorts -->	Two different nets unintentionally connected	Re-route affected nets, manually fix or use ECO routing
Opens -->	Missing connection between nets or pins	Reconnect net, fix missing vias
Antenna --> Violation	Long metal wire connected to a MOS gate accumulates charge during etch process	Add antenna diode, break wire with vias, use metal hopping
Crosstalk / Noise -->	Coupling capacitance between aggressor and victim nets	Increase spacing, shield critical nets, route on different layers
Density Violation	--> Metal density too low or too high â†’ CMP (planarity) issues	Add dummy metal fill or slotting
EM (Electromigration) / IR Drop -->	Excessive current density or voltage drop in power/clock nets	Widen wires, add parallel routing, use higher metal layer
Min Area / Min Hole Violation -->	Metal shapes too small (below min. area)	Increase shape area, merge with adjacent metal

***************************************************************************************************************************************************************************************************

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ°: ğ—–ğ—¹ğ—¼ğ—°ğ—¸ ğ—§ğ—¿ğ—²ğ—² ğ—¦ğ˜†ğ—»ğ˜ğ—µğ—²ğ˜€ğ—¶ğ˜€

Q) Steps in CTS optimization
Steps in CTS Optimization

CTS (Clock Tree Synthesis) is performed to distribute the clock signal to all sequential elements (flip-flops, latches) with minimum skew and balanced latency. After CTS, optimization ensures timing closure and clock quality.

1. Pre-CTS Preparation
Check Placement Quality: Ensure no cell overlaps, macros are properly placed, and congestion is acceptable.
Clock Definition: Verify proper clock constraints (period, uncertainty, generated clocks).
Check Timing: Fix pre-CTS timing violations (especially data path holds) to avoid surprises.

2. CTS Tree Building
Buffer Insertion: Insert clock buffers/inverters to build a balanced tree.
Skew & Latency Targeting: Minimize skew between flops and achieve desired insertion delay.
Clustering: Group nearby sinks to reduce tree complexity.
Shielding / Layer Assignment: Use preferred routing layers and shielding for noise immunity.

3. Post-CTS Optimization
After the clock tree is built, perform CTS Optimization to clean up violations.
Step	Goal
Skew Optimization	Adjust buffer sizing/placement to reduce skew between sinks.
Latency Optimization	Balance path delays so that all sinks see the clock at roughly the same time.
Transition (Slew) Fix	Resize or add buffers to keep clock transition (slew) within limits.
Clock Buffer Tree Balancing	Prevent excessive fanout, avoid pulse distortion.
Clock Gating Checks	Ensure gating cells are placed correctly and timing is met.

4. Post-CTS Timing Fixes
Setup/hold Fixing: Optimize data paths to remove setup or hold violations introduced due to new clock tree delays.
Re-buffering / ECO: If skew is too high, adjust clock tree buffers or rerun partial CTS.

5. Signoff Checks
Verify Skew: Skew should meet target (typically few ps for high-performance designs).
Verify Latency: Insertion delay must be within allowed range.
Power Check: Clock tree should not exceed power budget.
DRC/LVS Clean: Ensure no physical violations (spacing, electromigration on clock nets).

Summary Flow
Pre-CTS Setup â†’ Clock Tree Synthesis (Build Tree) â†’ Skew/Latency Optimization â†’ Post-CTS Timing Fix â†’ Signoff Verification

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Define insertion delay vs skew
1. Insertion Delay

Definition:
Insertion delay refers to the extra time added to a signal path when a component (like a gate, buffer, or interconnect) is inserted into that path. It is essentially the time it takes for a signal to propagate through that added element.
Skew is the difference in arrival times of the same clock signal (or a signal) at different points in a circuit.
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Example of useful skew application
Can help with setup and hold time.
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Clock tree power reduction techniques

| Technique                 | Approach                                      | Benefit                         |
| ------------------------- | --------------------------------------------- | ------------------------------- |
| Clock Gating              | Disable idle logic clocks                     | Reduces dynamic power           |
| Buffer/Tree Sizing        | Optimize buffer sizes in the clock tree       | Lower capacitance, lower power  |
| Low-Swing / Differential  | Reduce voltage swing                          | Cuts $V^2$ component of power   |
| Multi-Level Gating        | Hierarchical clock gating                     | Fine-grained power control      |
| Reducing Clock Load       | Minimize fanout / local buffering             | Lower switching power           |
| Clock Tree Topology       | H-tree, X-tree, mesh                          | Balanced skew + power reduction |
| Multi-Voltage / Frequency | Run less critical blocks slower or at lower V | Dynamic power saving            |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Multi-power domain CTS handling

| Technique / Concept        | Description                                       | Benefit                                   |
| -------------------------- | ------------------------------------------------- | ----------------------------------------- |
| Separate CTS per domain    | Build clock trees independently in each domain    | Avoids driving OFF regions                |
| Power-aware clock gating   | Gate clocks to powered-down domains               | Saves dynamic power                       |
| Level shifters             | Handle signals crossing different voltage domains | Prevents voltage mismatch / timing errors |
| Domain-aware skew planning | Skew analysis done per domain                     | Ensures timing closure                    |
| CDC / Clock merging        | Controlled crossing between domains               | Avoids metastability                      |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Types of clock gating

| Type / Technique            | How It Works                      | Pros                        | Cons                        |
| --------------------------- | --------------------------------- | --------------------------- | --------------------------- |
| Latch-Based                 | Latch controls gated clock        | Glitch-free, safe           | Area overhead               |
| Integrated / Register-Based | Flip-flop internally gates clock  | Area/power efficient        | Only sequential elements    |
| AND/OR Based                | Combinational logic gates clock   | Simple                      | Glitches possible           |
| Fine-Grained                | Gate clocks at FF/block level     | Maximum power saving        | Complex to implement        |
| Coarse-Grained              | Gate clocks at module/block level | Simple                      | Less power saving           |
| RTL Clock Gating            | Inserted in RTL                   | Tool-optimized, predictable | Limited to synthesis scope  |
| Tech-Based Clock Gating     | Added in post-synthesis/CTS       | Can optimize clock tree     | May need extra verification |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Placement optimization for CTS

| Optimization Technique  | Purpose / Benefit                              |
| ----------------------- | ---------------------------------------------- |
| Buffer Placement        | Minimize skew and delay, control load          |
| Flip-Flop Clustering    | Reduce wire length, power, and insertion delay |
| Clock Source Placement  | Reduce max skew, centralize driving region     |
| H-tree / Balanced Tree  | Ensure equal path lengths, minimize skew       |
| Critical Path Awareness | Optimize timing for high-speed paths           |
| Power-Aware Placement   | Avoid toggling in powered-down domains         |
| Timing-Driven Placement | Optimize setup/hold margins and skew           |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”


***************************************************************************************************************************************************************************************************
ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ±: ğ—§ğ—¶ğ—ºğ—¶ğ—»ğ—´ ğ—–ğ—¹ğ—¼ğ˜€ğ˜‚ğ—¿ğ—² ğ—®ğ—»ğ—± ğ— ğ—–ğ— ğ— 

Q) Why do we need multi-corner analysis?
A corner is a combination of process, voltage, and temperature (PVT) conditions under which the chip may operate.
Example corners:
Fast corner (FF, high V, low T) â†’ cells switch faster.
Slow corner (SS, low V, high T) â†’ cells switch slower.
Typical corner (TT) â†’ nominal conditions.
We need multi-corner analysis to guarantee timing closure across all real-world conditions, ensuring first-time-right silicon.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Setup fixing techniques

| Method               | Fix Strategy        | Trade-off                  |
| -------------------- | ------------------- | -------------------------- |
| Cell sizing / Low-Vt | Faster logic        | More leakage power         |
| Buffer insertion     | Reduce net delay    | Extra area & dynamic power |
| Placement / routing  | Shorter delay       | PnR complexity             |
| Useful clock skew    | Delay capture clock | Can worsen hold            |
| Pipeline / retiming  | Split path          | Adds latency               |
| Multicycle path      | Relax constraint    | Must be logically valid    |
| Voltage scaling      | Faster cells        | More dynamic power         |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Hold fixing techniques

| Method                      | Fix Strategy           | Trade-off                 |
| --------------------------- | ---------------------- | ------------------------- |
| Delay buffers / inverters   | Add delay in data path | Extra area & power        |
| HVT / smaller cells         | Slow down logic        | May hurt setup timing     |
| Routing detours / low metal | Increase net RC delay  | May increase congestion   |
| Downsize drivers            | Reduce drive strength  | Can affect fanout         |
| Useful clock skew           | Adjust clock arrival   | Must recheck setup timing |
| Lock-up latches             | Fix scan/DFT hold      | Adds area & complexity    |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Crosstalk-aware timing closure

ğŸ”¹ Crosstalk-Aware Timing Closure Techniques
1. Routing Optimization
Increase spacing between critical nets â†’ reduces coupling capacitance.
Shielding â†’ route a constant net (like VDD or GND) between aggressor and victim.
Layer assignment â†’ use orthogonal routing on adjacent metal layers.
Non-default routing rules (NDRs) â†’ wider wires or larger spacing on sensitive nets (e.g., clock).

2. Buffer Insertion
Break long victim nets by inserting buffers â†’ reduces the effective coupling length.
Restores signal strength and reduces susceptibility.

3. Cell Sizing / Driver Strength Control
Upsize victim driver â†’ makes it stronger, less affected by aggressors.
Downsize aggressor driver â†’ reduces aggressorâ€™s coupling effect.
Careful: must check setup/hold balance after changes.

4. Timing-Aware Fixes
Useful skew â†’ adjust clock arrival to compensate crosstalk-induced delays.
Path restructuring â†’ move critical nets to less noisy regions.
Critical net shielding (especially clocks) to minimize jitter.

5. SI-Aware STA & ECO Flow
Use crosstalk-aware STA tools (e.g., PrimeTime-SI, Tempus SI).
Perform ECO fixes where violations are reported:
Delay padding
Routing fixes
Buffer insertion

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Guard-band vs derating
Guard-banding
A design margining technique where you intentionally add slack requirements to cover variability.
Example: If the target clock is 1 GHz (1 ns), analysis is done at 0.9 ns to ensure safety.
Simple but pessimistic, often wastes performance/power.

Derating
Instead of shrinking the period, you scale individual delays in timing analysis to reflect variation.
Example: In OCV (On-Chip Variation), data path delays are multiplied by 1.05, and clock path delays by 0.95.
More fine-grained and realistic than guard-banding.

ğŸ‘‰ Key Difference:
Guard-band = margin on the entire path/timing budget.
Derating = margin on individual cells/nets, used in STA tools for OCV/AOCV/POCV.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Timing path prioritization
When fixing timing violations (setup/hold), not all paths are equally important. Prioritization helps focus optimization:

Criticality (Slack)
Paths with most negative slack are top priority.
Paths close to zero slack are secondary.

Path Type
Setup-critical paths â†’ typically long combinational logic (data paths).
Hold-critical paths â†’ typically short, fast paths (local connections).

Fanout & Load
High fanout nets affect multiple paths â†’ fixing them benefits many paths.

Path Depth & Hierarchy
Prioritize cross-domain or multi-cycle paths carefully.
Clock-domain-crossing (CDC) and scan paths need special treatment.

Design Intent
Some paths may be false paths or multi-cycle paths, and shouldnâ€™t be fixed by adding delay.

ğŸ‘‰ In practice: Tools assign a criticality score to each path; designers start with the worst negative slack (WNS) and total negative slack (TNS) contributors.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Clock jitter vs clock uncertainty
Clock Jitter
Variation of clock edge timing from its ideal position, due to PLL/oscillator noise, supply noise, etc.
Types:
Cycle-to-cycle jitter (difference between consecutive periods).
Period jitter (variation in clock period).
Phase jitter (deviation in edge position).

Clock Uncertainty
A timing analysis margin that models all sources of variation in clock arrival.
Includes:
Jitter
Skew

Crosstalk effects
Tool/user-added margins

ğŸ‘‰ Key Difference:
Jitter = physical clock variation (measured).
Uncertainty = timing budget margin (applied in STA to cover jitter + other unknowns).

***************************************************************************************************************************************************************************************************

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ²: ğ—¦ğ—¶ğ—´ğ—»ğ—¼ğ—³ğ—³ ğ—®ğ—»ğ—± ğ—£ğ—¼ğ˜„ğ—²ğ—¿

Q) Active vs standby power
 Dynamic vs leakage power

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Static vs dynamic IR drop
1. Static IR Drop
Definition: Voltage drop across the power grid due to average/static current consumption.
Cause: Resistive drop (
V=Iâ‹…R) from constant current draw of transistors, leakage currents, and steady power usage.
When? Happens under DC or steady-state load conditions.
Impact: If too large, reduces supply voltage margin, slowing down circuits or causing functional failures.

Fixes/Mitigation:
Widen power rails
Add more power straps/vias
Use lower-resistance metals in power grid

2. Dynamic IR Drop
Definition: Voltage drop across the power grid due to instantaneous switching activity (transient current spikes).
Cause: Sudden surge in current demand when many gates switch simultaneously (e.g., at a clock edge).
When? Happens during active switching events, not steady-state.
Impact: Temporary voltage dip â†’ timing violations, setup/hold failures, glitches.

Fixes/Mitigation:
Insert decoupling capacitors (decaps) to supply transient current locally
Optimize clock gating to reduce simultaneous switching
Strengthen power grid near hotspots

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) IR drop mitigation methods

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Role of dummy metal fill
Primary role: Ensure manufacturability (planar surface + density compliance).
Side effects: Adds parasitics â†’ must be considered in timing signoff.
Types:
Floating fill (not connected to anything, lower parasitics).
Grounded fill (tied to VSS, better shielding but higher capacitance).

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) EM checks in signoff
EM = gradual movement of metal atoms due to momentum transfer from high-density electron flow.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) DRC categories in routing
DRC categories in routing include width, spacing, enclosure, via, antenna, notch/jog, minimum area, density, and end-of-line rules â€” all to ensure manufacturability and reliability per foundry guidelines.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Why is LVS mandatory?
LVS is mandatory because it ensures that the layout implemented on silicon electrically matches the schematic/netlist â€” catching shorts, opens, and mismatches. Without LVS, a chip may pass DRC but still fail functionally after fabrication

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Role of end-cap cells

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Q) Methods to fix shorts/opens

***************************************************************************************************************************************************************************************************

ğ‘ğğœğ«ğ®ğ¢ğ­ğğ« ğ’ğœğ«ğğğ§ğ¢ğ§ğ 
1. Walk through your resume
2. ASIC design projects handled?
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

3. RTL to GDSII familiarity?
ğŸ”¹ RTL to GDSII Flow (Front-end â†’ Back-end â†’ Signoff)
1. RTL Design & Verification (Front-End)
RTL coding (Verilog/SystemVerilog/VHDL).
Functional verification â†’ simulation, assertions, coverage, UVM.
Linting & CDC (Clock Domain Crossing) checks.
DFT insertion at RTL â†’ scan chains, MBIST, boundary scan, JTAG logic.

2. Logic Synthesis
Convert RTL â†’ gate-level netlist using synthesis tools (Synopsys Design Compiler, Cadence Genus, etc.).
Apply constraints (SDC): timing, area, power.
Optimize for multi-mode multi-corner (MMMC).
Insert DFT (scan) logic if not already done.
Perform static timing analysis (pre-layout).

3. Design for Test (DFT)
Insert scan chains, BIST, boundary scan.
ATPG pattern generation.
Fault coverage analysis (stuck-at, transition, path delay, etc.).

4. Floorplanning
Define chip size, core vs IO ring.
Place macros/IPs, memory blocks, IO pads, power grid (IR drop planning).
Assign clock & reset distribution strategy.

5. Placement
Place standard cells in available rows.
Perform global placement â†’ legalize placement.
Optimize for timing, congestion, power.

6. Clock Tree Synthesis (CTS)
Build the clock tree (buffer/inverter insertion).
Minimize skew and insertion delay.
Apply useful skew if needed.
Perform pre-CTS STA and fix setup.

7. Routing
Global routing â†’ rough path assignment.
Detailed routing â†’ actual wires assigned in layers.
Consider DRC rules, crosstalk, shielding for critical nets (e.g., clock).
Perform post-route optimization for timing, SI (signal integrity).

8. Post-Route Optimization & Signoff
Timing closure across all corners.
Crosstalk-aware STA.
IR drop / EM (electromigration) analysis.
DRC/LVS checks â†’ physical correctness.
Antenna check for long wires.
Power analysis (dynamic & leakage).

9. GDSII Generation
Once signoff is clean â†’ final tape-out database generated in GDSII/OASIS format.
Sent to the foundry for fabrication.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

4. Tool expertise (Verilog, Synthesis, STA tools)?

5. Any post-silicon/tapeout experience?

***************************************************************************************************************************************************************************************************

ğŸ“ŒPanel 1: Basics + STA

1. What is STA?
Static Timing Analysis (STA) is a method to verify timing correctness of a digital design without applying test vectors.
It checks all possible paths between flip-flops, I/Os, and memories to ensure they meet setup and hold requirements under all clock and data conditions.
Called â€œstaticâ€ because it doesnâ€™t rely on dynamic simulation, but instead uses timing models and constraints.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

2. What is the difference between setup and hold time?

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

3. How do you fix routing congestion?

| Fix Area        | Techniques                                                 |
| --------------- | ---------------------------------------------------------- |
| Floorplan       | Spread macros, add channels, avoid notches, halos          |
| Placement       | Congestion-driven placement, spread cells, density control |
| Routing         | Higher layers, blockages, NDRs, shielding                  |
| Netlist/Logic   | Buffer insertion, replication, reduce fanout               |
| ECO / Iteration | Cell padding, local re-routing, congestion map checks      |

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

4. Explain the antenna effect.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

5. What does IR drop mean?
IR drop means the reduction in supply voltage at a cell due to resistive losses in the power grid (V = IÃ—R). 
It can be static or dynamic, and if severe, it slows down cells or causes functional failure. 
Fixes include strengthening the power grid, inserting decaps, optimizing cell placement, and reducing simultaneous switching.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

6. What is the difference between an LVT and an HVT cell?
LVT (Low-Vt cell):
Lower transistor threshold voltage.
Transistors switch faster, but leak more power.

HVT (High-Vt cell):
Higher transistor threshold voltage.
Transistors switch slower, but leak less power.

ğŸ‘‰ In modern SoCs, libraries usually offer multi-Vt flavors: HVT, SVT (Standard Vt), and LVT.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

7. Explain Electromigration (EM).
Electromigration is when current slowly moves atoms in a metal wire, creating breaks or shorts. 
Itâ€™s fixed by wider wires, extra vias, stronger metals, and careful routing

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

8. How do you handle clock domain crossing (CDC)?
Clock Domain Crossing happens when signals move between different clock domains. 
To handle CDC, we use synchronizer flip-flops for single-bit signals, asynchronous FIFOs for multi-bit buses, handshake protocols for control signals, and Gray codes for counters. 
CDC analysis tools are also used to detect potential metastability and data corruption.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

9. What is OCV?


***************************************************************************************************************************************************************************************************

ğŸ“ŒPanel 2: Floorplanning to Routing

1. What are the key steps in ASIC floorplanning?
2. Explain the difference between Global vs. Detailed routing.
3. What are halo and blockage definitions?
4. What are some of the main causes of congestion?
5. How do you handle pin access issues?
6. What are the different routing DRC types and their solutions?

***************************************************************************************************************************************************************************************************

ğŸ“ŒPanel 3: Signoff + Power Analysis
1. Explain the difference between Dynamic vs. Leakage power.
2. What is the purpose of metal fill, and how does it affect timing?
3. How do you debug IR drop?
4. What are the rules for Electromigration (EM) during signoff?
5. Why are filler cells important?
6. What are LVS and DRC checks?

***************************************************************************************************************************************************************************************************
ğŸ“ŒPanel 4: STA + Scripting

1. What is CRPR?
In timing analysis, we check:
When data launches (start) â†’ When data is captured (end).
Both launch clock and capture clock signals travel through the chip using buffers, wires, etc.
Sometimes, the two clocks travel through the same path for a while (they â€œreconvergeâ€).
Now, the STA tool tries to be safe (pessimistic):
It adds delay for the launch path.
It adds delay for the capture path.
But in the shared section, the delay gets counted twice.
That makes timing look worse than it actually is.
Without CRPR â†’ STA may report false timing violations.
With CRPR â†’ More accurate timing, fewer false alarms.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

2. How do you fix crosstalk noise/delay?
Place more distance between aggressor and victim nets to reduce coupling capacitance.
Route a constant net (like VDD or GND) between victim and aggressor â†’ acts as a shield.
Break a long victim net into two shorter segments with a buffer â†’ reduces coupling length.
Make the victim wire wider (lower resistance â†’ less delay impact).

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

3. How is delay computation performed in STA?

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

4. What are the different types of SDC constraints?
SDC = Synopsys Design Constraints
Itâ€™s an industry-standard format (Tcl-based) used to describe the timing, power, and design intent of a digital design to EDA tools (STA, synthesis, P&R).
Developed by Synopsys, but now used by almost all tools (PrimeTime, Innovus, Tempus, ICC, etc.).
Without SDC, tools donâ€™t know your clock definitions, I/O timings, or special exceptions â†’ so STA would give meaningless results.

Define how clocks behave.
create_clock â†’ Define primary clocks.
create_generated_clock â†’ Define derived clocks (dividers, PLLs, gated).
set_clock_uncertainty â†’ Jitter, skew margin.
set_clock_latency â†’ Clock distribution delay.
set_clock_transition â†’ Slew of clock.

2. I/O Timing Constraints
Tell STA when signals arrive/leave relative to the clock.
set_input_delay â†’ Delay from external source to chip input.
set_output_delay â†’ Delay from chip output to external sink.
set_driving_cell / set_input_transition â†’ Drive strength of input.
set_load â†’ Output load (capacitance).

3. Timing Exceptions
Relax or modify timing analysis where normal setup/hold checks donâ€™t apply.
set_false_path â†’ Ignore a path (not functionally used).
set_multicycle_path â†’ Allow multiple cycles for a path.
set_min/max_delay â†’ Override tool-calculated delay.
set_case_analysis â†’ Fix signal to constant (like scan_enable = 0/1).

4. Design Rule Constraints
Ensure signal quality (not just timing).
set_max_transition â†’ Limit signal slew.
set_max_capacitance â†’ Limit load per pin.
set_max_fanout â†’ Limit number of driven loads.

5. Operating Conditions / Libraries
set_operating_conditions â†’ PVT (process-voltage-temp) corners.
set_timing_derate â†’ Derating for on-chip variation.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

5. How would you use a Tcl script to find the top 10 critical paths?
Iâ€™d use PrimeTimeâ€™s report_timing -max_paths 10 to directly get the 10 most critical paths. For automation, 
Iâ€™d script it in Tcl with get_timing_paths, then extract attributes like startpoint, endpoint, and slack for custom reports.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

6. Explain the purpose of the max_transition constraint.
set_max_transition sets a limit on signal transition time (slew) at a pin or net.
Transition = the time it takes for a signal to rise from 10% â†’ 90% (or fall 90% â†’ 10%) of Vdd.

Example:
set_max_transition 0.5 [all_outputs]
â†’ Means each output signal must switch within 0.5 ns.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

7. How do you ensure Python script reusability?

***************************************************************************************************************************************************************************************************
ğŸ“ŒPanel 5: Timing Closure + MCMM
1. What is MCMM?
2. What is the process for Setup vs. Hold ECOs?
3. What are some SI-aware closure techniques?
4. Explain the difference between Derating vs. Margin.
5. How do you handle violating paths?
***************************************************************************************************************************************************************************************************
ğŸ“ŒExtra: Common Questions (All Rounds)
1. What is the difference between Cell vs. Net delay?
2. Explain crosstalk delay.
3. What is RC extraction?
4. How do you handle a glitch?
5. Explain a timing arc.
6. Define clock skew, slack, and slew.
7. How do you debug setup/hold failures?
8. Design a divide-by-N counter.
9. Design an FSM that acts as a 101 detector.
10. What is the difference between a Mealy vs. Moore machine?



APPLE - SOC Physical Design Interview

1. Walk through your resume
2. Physical design projects?
3. Tools youâ€™ve worked on?
4. Full flow experience?

Initial Technical Interview (1 Hour):

1. What is STA?
2. Explain setup/hold time violations
3. What is OCV and how is it modeled?
4. What is clock reconvergence pessimism?
5. Difference: LVT vs HVT cells
6. Impact of threshold voltage on power
7. What is IR drop?
8. What is antenna effect?
9. What is EM (Electromigration)?
10. How do you fix routing congestion?
11. What is CDC?

Panel 1: STA and Scripting

1. What is CRPR?
2. How do you fix crosstalk issues?
3. Delay calculation in STA?
4. SDC constraints types?
5. Tcl script to extract top 10 critical paths?
6. What is max\_transition constraint?
7. How do you write reusable scripts in Python?

Panel 2: Synthesis, DFT, Memory

1. Difference: combinational vs sequential logic
2. What is physical-aware synthesis?
3. Floorplan impact on synthesis?
4. What is scan chain?
5. How are scan chains reordered post-layout?
6. SRAM vs Register File?
7. What is a shift register?
8. Memory BIST vs logic BIST?
9. What is ATPG?

Panel 3: Floorplan to Route:

1. Floorplan steps?
2. Macro placement strategy?
3. What is halo and blockage?
4. Row utilization?
5. What causes congestion?
6. What is pin accessibility issue?
7. Global vs detailed routing?
8. What are routing DRCs youâ€™ve fixed?

Panel 4: Clock Tree Synthesis: 

1. CTS flow?
2. What is latency vs skew?
3. Useful skew concept?
4. How to reduce clock tree power?
5. How do you balance CTS across power domains?
6. Clock gating techniques?
7. CTS-aware placement?

Panel 5: Timing Closure and MCMM

1. What is MCMM and why is it needed?
2. What are setup ECOs?
3. What are hold ECOs?
4. SI-aware timing closure?
5. Difference between derating and margin?
6. What is path grouping?
7. Clock uncertainty types?

Panel 6: Signoff and Power

1. Dynamic vs leakage power?
2. What is IR drop?
3. How do you fix IR drop?
4. What is metal fill?
5. EM rules in signoff?
6. Common DRC errors?
7. What is LVS and why is it needed?
8. What are filler cells?
9. How do you fix open shorts?

Extra Common Questions (All Rounds):

1. What is cross-talk delay?
2. What is cell delay vs net delay?
3. How does process corner affect timing?
4. Explain RC extraction
5. What is double patterning?
6. What is multi-Vt optimization?
7. What is a scan-def insertion flow?
8. What is timing budgeting?
9. How to debug a failing timing path?
10. What is a timing arc?
11. What is glitch and how is it handled?


NVIDIA - SOC Physical Design Engineer Role

ğ—¥ğ—²ğ—°ğ—¿ğ˜‚ğ—¶ğ˜ğ—²ğ—¿ ğ—¥ğ—¼ğ˜‚ğ—»ğ—±:
Walk me through your project experience
Have you handled block-level or top-level design?
Familiar tools and flows?
Challenges you faced in tape-out?

ğ—œğ—»ğ—¶ğ˜ğ—¶ğ—®ğ—¹ ğ—§ğ—²ğ—°ğ—µğ—»ğ—¶ğ—°ğ—®ğ—¹ ğ—œğ—»ğ˜ğ—²ğ—¿ğ˜ƒğ—¶ğ—²ğ˜„ (ğŸ­ ğ—›ğ—¼ğ˜‚ğ—¿):
Explain timing closure flow
Setup vs recovery/removal checks
What is cross-corner analysis?
Explain clock domain crossing issues
Difference between multi-Vt and multi-Vdd
Leakage vs dynamic power impact
What is voltage droop?
Metal density rules?
Causes of electromigration?
Placement congestion fixes?
Explain asynchronous FIFO

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ­: ğ—¦ğ—§ğ—” ğ—®ğ—»ğ—± ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ğ—¶ğ—»ğ—´
Explain AOCV vs POCV
Crosstalk delay vs crosstalk noise
Types of timing paths in STA
Key SDC commands for false path
Write Tcl to find violating endpoints
What is max_capacitance constraint?
How do you modularize Python scripts?

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ®: ğ—¦ğ˜†ğ—»ğ˜ğ—µğ—²ğ˜€ğ—¶ğ˜€, ğ——ğ—™ğ—§, ğ— ğ—²ğ—ºğ—¼ğ—¿ğ˜†
Latch vs Flip-Flop
Multi-bit flop usage
Floorplan-driven synthesis
What is boundary scan?
Scan stitching at block level?
Difference: SRAM vs DRAM
Application of shift registers
Logic BIST vs MBIST
Fault coverage in ATPG

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ¯: ğ—™ğ—¹ğ—¼ğ—¼ğ—¿ğ—½ğ—¹ğ—®ğ—» ğ˜ğ—¼ ğ—¥ğ—¼ğ˜‚ğ˜ğ—²
Key floorplan quality checks
Macro placement with channel spacing
Difference: keep-out vs blockage
How utilization affects IR drop
Sources of routing congestion
Pin access issues in standard cells
Difference: track-based vs grid routing
Common routing violations

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ°: ğ—–ğ—¹ğ—¼ğ—°ğ—¸ ğ—§ğ—¿ğ—²ğ—² ğ—¦ğ˜†ğ—»ğ˜ğ—µğ—²ğ˜€ğ—¶ğ˜€
Steps in CTS optimization
Define insertion delay vs skew
Example of useful skew application
Clock tree power reduction techniques
Multi-power domain CTS handling
Types of clock gating
Placement optimization for CTS

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ±: ğ—§ğ—¶ğ—ºğ—¶ğ—»ğ—´ ğ—–ğ—¹ğ—¼ğ˜€ğ˜‚ğ—¿ğ—² ğ—®ğ—»ğ—± ğ— ğ—–ğ— ğ— 
Why do we need multi-corner analysis?
Setup fixing techniques
Hold fixing techniques
Crosstalk-aware timing closure
Guard-band vs derating
Timing path prioritization
Clock jitter vs clock uncertainty

ğ—£ğ—®ğ—»ğ—²ğ—¹ ğŸ²: ğ—¦ğ—¶ğ—´ğ—»ğ—¼ğ—³ğ—³ ğ—®ğ—»ğ—± ğ—£ğ—¼ğ˜„ğ—²ğ—¿
Active vs standby power
Static vs dynamic IR drop
IR drop mitigation methods
Role of dummy metal fill
EM checks in signoff
DRC categories in routing
Why is LVS mandatory?
Role of end-cap cells
Methods to fix shorts/opens





PD
1. What is HFNS?
2. HFNS is checked on which net/pin it works during the synth and placement stage.
3. What is a DCD check?
4. When you get the DCD even after using the CLK buffer, how do you fix it?
5. How to fix the glitch?
6. What is the difference between clock mesh and conventional clock?
7. What is the difference between a false path and a disabled timing arc?
8. If you have a large latency of 200 ps but in design are getting 300 ps, what could be the reason for it? And how can it be fixed?
9. What are the contents of the UPF file?
10. Do we need UPF for a single-voltage design?
11. In the CTS stage, if utilization is 90%, then we donâ€™t get by connecting the supply net?
12. What are set_eco_power_intent and max_eco?
13. What are useful PrimeTime commands?
14. In the placement-completed design, suppose there are three timings via block ports: a) with 800 ps b) with 300 ps c) with 50 ps What are your approaches to fix it?
15. How to decide the floor plan height and width at the beginning of the design?
16. What is utilization?
17. How do you do power optimization at the placement stage?
18. What are the report timing options you will use to dump the timing report?
19. What is the difference between -max_paths and -nworst?
20. What are macro placement guidelines?
21. How do you decide the channel spacing?
22. Suppose you have a macro in which some pins are at the periphery and some pins are in between; what will be your approach to placing it?
23. Suppose you have created a hard bound for a group of 800 cells, and there are 1000 cells in that group. What will happen?
24. What are setup fixes?
25. Suppose you donâ€™t have optimization options with you but have a data path; then what will you do?
26. Pulling off launch fixes holds in the current path, which will be set up in the previous path. What will be your approach to fix it?
27. What are hold fixes?
28. What is clock gating?
29. Why donâ€™t we use a high-drive AND gate? Why only ICG2?
30. Suppose we have a highly congested design and we canâ€™t go for metal hopping or double width. What will be your approach to fix i
