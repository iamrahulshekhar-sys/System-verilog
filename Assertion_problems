1. Write an assertion to check that once the signal start is asserted, the done signal goes high within exactly 4 clock cycles.
assert propert (@(posedge clk) start |-> ##4 done);
*-------------------------------------------------------------------------------------------------------------------------------------*

2. Write an assertion to verify that when req goes high, ack must go high within 2 to 5 clock cycles.
assert property (@(posedge clk) $rose(req) |-> ##[2:5] ack); 
*-------------------------------------------------------------------------------------------------------------------------------------*

3. Write a concurrent assertion to check that when a valid signal is high, the ready signal should also be high within the same cycle.
assert property(@(posedge clk) valid |-> ready);
*-------------------------------------------------------------------------------------------------------------------------------------*

4. Write an assertion that ensures after a reset signal goes low (de-asserted), a data_valid signal must become high within 3 clock cycles and remain high for at least 2 cycles.
assert property (@(posedge clk) $fell(reset) |-> ##[1:3] (data_valid[*2]));
*-------------------------------------------------------------------------------------------------------------------------------------*

5. Write an assertion to check that if "write_en" goes high, the "data_out" signal must change within 2 clock cycles
assert property(@(posedge clk) $rose(write_en) |-> ##[1:2] data_out!=($past(data_out)));
*-------------------------------------------------------------------------------------------------------------------------------------*

6. Write an assertion to ensure that the signal busy is low when both enable and reset signals are high.
assert property (@(posedge clk) (en && rst) |-> !signal);
*-------------------------------------------------------------------------------------------------------------------------------------*

7. Write an assertion to check that the valid signal is not asserted for more than 3 consecutive clock cycles. (not asserted=not high)
assert property (@(posedge clk) valid |-> ##[1:3] !valid);
*-------------------------------------------------------------------------------------------------------------------------------------*

8. Write an assertion to verify that after a read operation is initiated (read_en goes high), the data_out signal should not change for 5 clock cycles unless read_en goes low.
assert property (@(posedge clk) $rose(read_en) |-> (read_en throughout (data_out == $past(data_out))[*5]) );
*-------------------------------------------------------------------------------------------------------------------------------------*

9. Write an assertion to check that after the load signal is asserted, a ready signal must be asserted within 10 cycles, but not before 3 cycles.
assert property (@(posedge clk) $rose(load) |-> ##[3:10] ready);
*-------------------------------------------------------------------------------------------------------------------------------------*

10. Write an assertion that checks if reset is de-asserted, the init_complete must go high exactly after 6 clock cycles and remain high for 2 cycles.
assert property (@(posedge clk) !reset |-> ##6 (init_complete[*2]));
*-------------------------------------------------------------------------------------------------------------------------------------*

11. Write an assertion to check that a FIFO is never read (read_en high) when it is empty (fifo_empty high).
assert property(@(posedge clk) empty |-> !read_en);
*-------------------------------------------------------------------------------------------------------------------------------------*

12. Write an assertion to verify that a burst transfer of 4 data cycles occurs (i.e., data must change 4 times in consecutive cycles).
assert property (@(posedge clk) burst |-> ##1(data != $past(data)) ##1(data != $past(data,1)) ##1(data != $past(data,2)) ##1(data != $past(data,3))); 
*-------------------------------------------------------------------------------------------------------------------------------------*

13. Write an assertion to check that write_enable is not asserted without a valid_address being asserted.
assert property (@(posedge clk)  write_enable |-> valid_address);
*-------------------------------------------------------------------------------------------------------------------------------------*

14. Write an assertion to ensure if reset is de-asserted, the signal counter increments on every clock cycle for 5 consecutive clock cycles.
assert property @($fell(reset) |-> ##1(counter == $past(counter)+1) ##1(counter == $past(counter,2)+1) ##1(counter == $past(counter,3)+1) ##1(counter == $past(counter,4)+1) ##1(counter == $past(counter,5)+1); 
*-------------------------------------------------------------------------------------------------------------------------------------*

15. Write an assertion to check that clk toggles correctly (i.e., no glitches occur) for at least 100 clock cycles.
sequence toggle;
(clk != $past(clk))[*100];
endsequence
assert property (@(posedge clk) toggle);
*-------------------------------------------------------------------------------------------------------------------------------------*

16. Write an assertion to check that a sequence of events (a, b, c) happens in strict order, where each event occurs exactly 2 cycles apart.
sequence a_b_c;
a ##2 b ##2 c;
endsequence
assert property(@(posedge clk) a_b_c);
*-------------------------------------------------------------------------------------------------------------------------------------*

17. Write an assertion to verify that two signals 'signal A' and 'signal B' never toggle in the same cycle.
assert property (@(posedge clk) not ($changed(signalA) and $changed(signalB));
*-------------------------------------------------------------------------------------------------------------------------------------*

18. Write an assertion to make sure that a 5-bit grant signal only has one bit set at any time?
assert property ( @(posedge clk) disable iff (!reset) $countones(grant) == 1);
*-------------------------------------------------------------------------------------------------------------------------------------*

19. Write an assertion which checks that once a valid request is asserted by the master, the arbiter provides a grant within 2 to 5 clock cycles.
assert property (@(posedge clk) valid |-> ##[2:5] grant);
*-------------------------------------------------------------------------------------------------------------------------------------*

20. In a RESP operation, request must be true immediately, grant must be true 3 clock cycles later, followed by request being false, and then grant being false.
assert property (@(posedge clk) disable iff(!reset) resp |-> (request ##3 grant ##1 !request ##1 !grant));
*-------------------------------------------------------------------------------------------------------------------------------------*

21. The signals signal_a and signal_b may only be asserted if signal_c is asserted.
assert property ( @(posedge clk) disable iff(!reset) (signal_a || signal_b) -> signal_c);
*-------------------------------------------------------------------------------------------------------------------------------------*

22. Request must true at the current cycle; grant must become true sometime between 1 cycle after request and the end of time.
assert proerty (@(posedge clk) disable iff(!reset) request |-> ##[1:$] grant);
*-------------------------------------------------------------------------------------------------------------------------------------*

23. Assert that req is followed by ack within 3 cycles.
assert property (@(posedge clk) req |-> ##[0:3] ack);
*-------------------------------------------------------------------------------------------------------------------------------------*

24. Ensure reset is deasserted within 5 cycles of power-up.
assert property (@(posedge clk) power_up |-> ##[1:5] !reset);
*-------------------------------------------------------------------------------------------------------------------------------------*

25. Assert that wvalid stays high for at most 2 cycles without wready.
assert property (@(posedge clk) wvalid && !wready |-> (wvalid && !wready)[*1:2] ##1 (!wvalid or wready));
*-------------------------------------------------------------------------------------------------------------------------------------*

26. Ensure FIFO never underflows (read without empty).
assert property (@(posedge clk) empty |-> !read);
*-------------------------------------------------------------------------------------------------------------------------------------*

27. Assert that no transaction occurs during reset.
assert property (@(posedge clk) reset |-> !transaction);
*-------------------------------------------------------------------------------------------------------------------------------------*

28. Assert burst transfers complete with burst_len cycles.
assert property (@(posedge clk) burst_start |-> (burst_active[*burst_len] ##1 burst_done));
*-------------------------------------------------------------------------------------------------------------------------------------*

29. Check that write happens only when enable is high.
assert property (@(posedge clk) write |-> enable);
*-------------------------------------------------------------------------------------------------------------------------------------*

30. Assert a transaction ID is not repeated consecutively.
assert property (@(posedge clk) trans |-> (trans_id != ($past(trans_id)));
*-------------------------------------------------------------------------------------------------------------------------------------*

31. Ensure address in a write is aligned (addr % 4 == 0).
assert property (@(posedge clk) (write || read) |-> (addr[1:0] == 2'b00));
*-------------------------------------------------------------------------------------------------------------------------------------*

32. Assert signal done is only asserted after start.
assert property (@(posedge clk) !$past(start) |-> !done);
*-------------------------------------------------------------------------------------------------------------------------------------*

33. Check arvalid is followed by arready within 5 cycles.
assert property (@(posedge clk) $rose(arvalid) |=> ##[0:5]arready;
*-------------------------------------------------------------------------------------------------------------------------------------*

34. Assert that clock frequency doesn’t skip (no 2 rising edges too close).
*-------------------------------------------------------------------------------------------------------------------------------------*

35. Check that packet size is always less than max allowed size.
parameter int MAX_SIZE = 1024;
assert property (@(posedge clk) packet_valid |-> packet_size < MAX_SIZE);
*-------------------------------------------------------------------------------------------------------------------------------------*

36. Ensure grant signal is not active for more than 10 cycles.
assert property (@(posedge clk) not (grant [*11]));
*-------------------------------------------------------------------------------------------------------------------------------------*

37. Assert temperature never exceeds 120°C.
assert property (@(posedge clk)  (temp <= 120));
*-------------------------------------------------------------------------------------------------------------------------------------*

38. Ensure data_valid is only high when data_ready is also high.
assert property (@(posedge clk) data_valid |-> data_ready);
*-------------------------------------------------------------------------------------------------------------------------------------*

39. Assert a valid handshake occurs before any data is transferred.

*-------------------------------------------------------------------------------------------------------------------------------------*

Check that a signal toggles at least once every 20 cycles.
*-------------------------------------------------------------------------------------------------------------------------------------*

Ensure no packet is dropped (valid & !ready case).
*-------------------------------------------------------------------------------------------------------------------------------------*

Check that fsm never enters an invalid or undefined state.
*-------------------------------------------------------------------------------------------------------------------------------------*









